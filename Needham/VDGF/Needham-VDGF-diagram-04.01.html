<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Needham – Central Projection</title>
<style>
html,body{margin:0;height:100%;background:#000;overflow:hidden}
.label{
  color:#ccc;font-size:13px;font-family:Georgia,serif;font-style:italic;
  text-shadow:0 0 8px #000,0 0 3px #000;
  pointer-events:none;
}
</style>
</head>
<body>
<script type="module">
import * as THREE from "https://esm.sh/three@0.160.0";
import { OrbitControls } from "https://esm.sh/three@0.160.0/examples/jsm/controls/OrbitControls.js";
import { CSS3DRenderer, CSS3DObject } from "https://esm.sh/three@0.160.0/examples/jsm/renderers/CSS3DRenderer.js";

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

const camera = new THREE.PerspectiveCamera(35, innerWidth/innerHeight, 0.01, 100);
camera.position.set(0.05, 4.37, 11.29);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

const labelRenderer = new CSS3DRenderer();
labelRenderer.setSize(innerWidth, innerHeight);
labelRenderer.domElement.style.position = "absolute";
labelRenderer.domElement.style.top = "0";
labelRenderer.domElement.style.pointerEvents = "none";
document.body.appendChild(labelRenderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.target.set(0, 0.8, 0);

const R = 2;  // Hemisphere radius

// Tangent plane
const planeGeo = new THREE.PlaneGeometry(12, 8);
const planeMat = new THREE.MeshBasicMaterial({ color: 0x151515, side: THREE.DoubleSide });
const plane = new THREE.Mesh(planeGeo, planeMat);
plane.rotation.x = -Math.PI/2;
scene.add(plane);

// Plane outline
const planeEdges = new THREE.EdgesGeometry(planeGeo);
const planeOutline = new THREE.LineSegments(planeEdges, new THREE.LineBasicMaterial({color: 0xcccccc}));
planeOutline.rotation.x = -Math.PI/2;
planeOutline.position.y = 0.001;
scene.add(planeOutline);

labelLarge("(complex)<br>tangent plane", new THREE.Vector3(4, 0.05, 1));

// Hemisphere
const hemiGeo = new THREE.SphereGeometry(R, 64, 32, 0, Math.PI*2, 0, Math.PI/2);

// Outer surface (opaque like plane, so it occludes lines)
const hemiMat = new THREE.MeshBasicMaterial({
  color: 0x2a2a2a,
  side: THREE.FrontSide
});
const hemi = new THREE.Mesh(hemiGeo, hemiMat);
hemi.rotation.x = Math.PI;
hemi.position.y = R;
scene.add(hemi);

// Inner surface (darker)
const hemiInnerMat = new THREE.MeshBasicMaterial({
  color: 0x1a1a1a,
  side: THREE.BackSide
});
const hemiInner = new THREE.Mesh(hemiGeo, hemiInnerMat);
hemiInner.rotation.x = Math.PI;
hemiInner.position.y = R;
scene.add(hemiInner);

// Outline (inverted hull)
const hemiOutlineGeo = new THREE.SphereGeometry(R + 0.015, 64, 32, 0, Math.PI*2, 0, Math.PI/2);
const hemiOutline = new THREE.Mesh(hemiOutlineGeo, new THREE.MeshBasicMaterial({
  color: 0xcccccc,
  side: THREE.BackSide
}));
hemiOutline.rotation.x = Math.PI;
hemiOutline.position.y = R;
scene.add(hemiOutline);

// Rim circle at y=R
const rimPts = [...Array(128)].map((_, i) => {
  const a = i/128 * Math.PI * 2;
  return new THREE.Vector3(R * Math.cos(a), R, R * Math.sin(a));
});
rimPts.push(rimPts[0]);
scene.add(new THREE.Line(
  new THREE.BufferGeometry().setFromPoints(rimPts),
  new THREE.LineBasicMaterial({color: 0xcccccc})
));

// O - Origin (where pole touches plane)
const O = new THREE.Vector3(0, 0, 0);
scene.add(dot(O));
label("O", O.clone().add(new THREE.Vector3(0.15, 0.1, 0)));

// C - Center of sphere (at rim level)
const C = new THREE.Vector3(0, R, 0);
scene.add(dot(C));
label("C", C.clone().add(new THREE.Vector3(0.15, 0.15, 0)));

// Pick a point on hemisphere
const theta = 1.9;  // Angle around Y axis
const phi = 0.9;    // Angle from pole (0=pole, PI/2=rim)

// Calculate ẑ position on hemisphere surface
const zHat = new THREE.Vector3(
  R * Math.sin(phi) * Math.cos(theta),
  R * (1 - Math.cos(phi)),  // Height: 0 at pole, R at rim
  R * Math.sin(phi) * Math.sin(theta)
);
scene.add(dot(zHat));
label("ẑ", zHat.clone().add(new THREE.Vector3(0.1, -0.15, 0)));

// Project from C through ẑ to plane (y=0)
const dir = zHat.clone().sub(C);          // Direction from C to ẑ
const t = -C.y / dir.y;                   // Parameter to reach y=0
const z = C.clone().add(dir.multiplyScalar(t));
scene.add(dot(z));
label("z", z.clone().add(new THREE.Vector3(0.1, -0.15, 0)));

// Draw the projection ray
scene.add(line(C, z));

//Helper functions
function dot(pos, color = 0xffffff, size = 0.05) {
  const mesh = new THREE.Mesh(
    new THREE.SphereGeometry(size, 16, 16),
    new THREE.MeshBasicMaterial({ color, depthTest: false })
  );
  mesh.renderOrder = 999;  // Render last, on top of everything
  mesh.position.copy(pos);
  return mesh;
}
function line(a, b, color = 0xffffff) {
  const group = new THREE.Group();
  const points = [a, b];
  
  // Solid line for visible parts (normal depth test)
  const solidMat = new THREE.LineBasicMaterial({ color, depthTest: true });
  const solid = new THREE.Line(new THREE.BufferGeometry().setFromPoints(points), solidMat);
  solid.renderOrder = 1;  // Render after hemisphere
  group.add(solid);
  
  // Dashed line for occluded parts (render only behind geometry)
  const dashedMat = new THREE.LineDashedMaterial({
    color,
    dashSize: 0.08,
    gapSize: 0.04,
    depthFunc: THREE.GreaterDepth
  });
  const dashed = new THREE.Line(new THREE.BufferGeometry().setFromPoints(points), dashedMat);
  dashed.computeLineDistances();
  dashed.renderOrder = 1;  // Render after hemisphere
  group.add(dashed);
  
  group.renderOrder = 1;
  return group;
}
function label(text, pos) {
  const div = document.createElement("div");
  div.className = "label";
  div.innerHTML = text;
  const lbl = new CSS3DObject(div);
  lbl.position.copy(pos);
  lbl.scale.setScalar(0.01);
  scene.add(lbl);
}
function labelLarge(text, pos) {
  const div = document.createElement("div");
  div.className = "label";
  div.style.fontSize = "18px";
  div.innerHTML = text;
  const lbl = new CSS3DObject(div);
  lbl.position.copy(pos);
  lbl.scale.setScalar(0.01);
  scene.add(lbl);
}

//Animation loop
function animate() {
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
  labelRenderer.render(scene, camera);
}
animate();

//Event handlers
addEventListener("resize", () => {
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
  labelRenderer.setSize(innerWidth, innerHeight);
});

// Press 'P' to print camera position
addEventListener("keydown", (e) => {
  if (e.key === 'p' || e.key === 'P') {
    const p = camera.position;
    const t = controls.target;
    alert(`Position: (${p.x.toFixed(2)}, ${p.y.toFixed(2)}, ${p.z.toFixed(2)})\nTarget: (${t.x.toFixed(2)}, ${t.y.toFixed(2)}, ${t.z.toFixed(2)})`);
  }
});
</script>
</body>
</html>
