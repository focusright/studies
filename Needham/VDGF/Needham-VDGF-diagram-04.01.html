<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Needham - Hemisphere + Tangent Plane</title>
<style>
html,body{margin:0;height:100%;background:#000;overflow:hidden}
.label{
  color:#ccc;font-size:13px;font-family:Georgia,serif;font-style:italic;
  text-shadow:0 0 8px #000,0 0 3px #000;
  pointer-events:none;
  text-align:center;
}
.label-box{
  color:#ccc;font-size:12px;font-family:Georgia,serif;font-style:italic;
  background:rgba(30,30,30,.85);
  border:1px solid rgba(150,150,150,.5);
  border-radius:4px;padding:2px 8px;
  text-shadow:0 0 4px #000;
  pointer-events:none;
}
</style>
</head>
<body>
<script type="module">
import * as THREE from "https://esm.sh/three@0.160.0";
import { OrbitControls } from "https://esm.sh/three@0.160.0/examples/jsm/controls/OrbitControls.js";
import { CSS3DRenderer, CSS3DObject } from "https://esm.sh/three@0.160.0/examples/jsm/renderers/CSS3DRenderer.js";

const BLACK = new THREE.Color(0x000000);
const WHITE = new THREE.Color(0xffffff);
const YELLOW = new THREE.Color(0xffff00);

const scene = new THREE.Scene();
scene.background = new THREE.Color(BLACK);

const camera = new THREE.PerspectiveCamera(35, innerWidth/innerHeight, 0.01, 100);
camera.position.set(0, 4, 13);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

const labelRenderer = new CSS3DRenderer();
labelRenderer.setSize(innerWidth, innerHeight);
labelRenderer.domElement.style.position = "absolute";
labelRenderer.domElement.style.top = "0";
labelRenderer.domElement.style.pointerEvents = "none";
document.body.appendChild(labelRenderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.target.set(0, 0.8, 0);

const R = 2;  // Hemisphere radius

// Tangent plane
const planeGeo = new THREE.PlaneGeometry(12, 8);
const planeMat = new THREE.MeshBasicMaterial({ color: 0x151515, side: THREE.DoubleSide });
const plane = new THREE.Mesh(planeGeo, planeMat);
plane.rotation.x = -Math.PI/2;
scene.add(plane);

// Plane outline
const planeEdges = new THREE.EdgesGeometry(planeGeo);
const planeOutline = new THREE.LineSegments(planeEdges, new THREE.LineBasicMaterial({color: 0xcccccc}));
planeOutline.rotation.x = -Math.PI/2;
planeOutline.position.y = 0.001;
scene.add(planeOutline);

labelLarge("(complex)<br>tangent plane", new THREE.Vector3(4, 0.05, 1));

// Hemisphere
const hemiGeo = new THREE.SphereGeometry(R, 64, 32, 0, Math.PI*2, 0, Math.PI/2);

// Outer surface (opaque like plane, so it occludes lines)
const hemiMat = new THREE.MeshBasicMaterial({
  color: 0x2a2a2a,
  side: THREE.FrontSide
});
const hemi = new THREE.Mesh(hemiGeo, hemiMat);
hemi.rotation.x = Math.PI;
hemi.position.y = R;
scene.add(hemi);

// Inner surface (darker)
const hemiInnerMat = new THREE.MeshBasicMaterial({
  color: 0x1a1a1a,
  side: THREE.BackSide
});
const hemiInner = new THREE.Mesh(hemiGeo, hemiInnerMat);
hemiInner.rotation.x = Math.PI;
hemiInner.position.y = R;
scene.add(hemiInner);

// Outline (inverted hull)
const hemiOutlineGeo = new THREE.SphereGeometry(R + 0.015, 64, 32, 0, Math.PI*2, 0, Math.PI/2);
const hemiOutline = new THREE.Mesh(hemiOutlineGeo, new THREE.MeshBasicMaterial({
  color: 0xcccccc,
  side: THREE.BackSide
}));
hemiOutline.rotation.x = Math.PI;
hemiOutline.position.y = R;
scene.add(hemiOutline);

// Rim circle at y=R
const rimPts = [...Array(128)].map((_, i) => {
  const a = i/128 * Math.PI * 2;
  return new THREE.Vector3(R * Math.cos(a), R, R * Math.sin(a));
});
rimPts.push(rimPts[0]);
scene.add(new THREE.Line(
  new THREE.BufferGeometry().setFromPoints(rimPts),
  new THREE.LineBasicMaterial({color: 0xcccccc})
));

// O - Origin (where pole touches plane)
const O = new THREE.Vector3(0, 0, 0);
scene.add(circle(O, new THREE.Vector3(0, 1, 0), WHITE, 0.04, 0.008));
label("O", O.clone().add(new THREE.Vector3(0, 0.1, 0)));

// C - Center of sphere (at rim level)
const C = new THREE.Vector3(0, R, 0);
scene.add(dot(C));
label("C", C.clone().add(new THREE.Vector3(0, 0.15, 0)));

// z at distance 2 from O (direction chosen first, then zHat placed on C→z)
const theta = 1.9;  // Angle around Y axis (determines direction from O)
const phi = 0.9;    // Angle from pole (0=pole, PI/2=rim)
const zDirFromO = new THREE.Vector3(
  Math.sin(phi) * Math.cos(theta),
  0,
  Math.sin(phi) * Math.sin(theta)
).normalize();
const z = O.clone().add(zDirFromO.multiplyScalar(2));

// ẑ where ray C→z meets the hemisphere (sphere center C, radius R)
const CtoZ = z.clone().sub(C).normalize();
const zHat = C.clone().add(CtoZ.multiplyScalar(R));
const zHatNormal = zHat.clone().sub(C).normalize();
scene.add(circle(zHat, zHatNormal, WHITE, 0.04, 0.008));
label("<span style='position:relative'>z<span style='position:absolute;left:0;right:0;top:-0.5em;text-align:center'>^</span></span>", zHat.clone().add(new THREE.Vector3(0.1, -0, 0)));
// Normal at z: points up (flat on plane)
const zNormal = new THREE.Vector3(0, 1, 0);
scene.add(circle(z, zNormal));
label("z", z.clone().add(new THREE.Vector3(0, -0.1, 0)));

// Draw the projection ray C → z
scene.add(line(C, z));

// q̂ - another point on hemisphere (close to ẑ so zq arrow is short)
const thetaQ = 1.93;
const phiQ = 0.93;
const qHat = new THREE.Vector3(
  R * Math.sin(phiQ) * Math.cos(thetaQ),
  R * (1 - Math.cos(phiQ)),
  R * Math.sin(phiQ) * Math.sin(thetaQ)
);
const qHatNormal = qHat.clone().sub(new THREE.Vector3(0, R, 0)).normalize();
scene.add(circle(qHat, qHatNormal, WHITE, 0.04, 0.008));
label("<span style='position:relative'>q<span style='position:absolute;left:0;right:0;top:-0.5em;text-align:center'>^</span></span>", qHat.clone().add(new THREE.Vector3(-0.1, 0.1, 0)));

// Project from C through q̂ to plane (y=0)
const dirQ = qHat.clone().sub(C);
const tQ = -C.y / dirQ.y;
const q = C.clone().add(dirQ.multiplyScalar(tQ));
scene.add(circle(q, new THREE.Vector3(0, 1, 0)));
label("q", q.clone().add(new THREE.Vector3(0, -0.1, 0)));

// Draw the projection ray C → q
scene.add(line(C, q));

// Dense dotted line extending from q (not occluded, parallel to z-q arrow)
const qExtendDir = q.clone().sub(z).normalize();  // Same direction as z-q arrow
scene.add(denseDottedLine(q, q.clone().add(qExtendDir.multiplyScalar(0.5))));

// Dense dotted line from z going left (similar to OLeftEnd)
const zLeftEnd = z.clone().add(new THREE.Vector3(-1.2, 0, 0));
scene.add(denseDottedLine(z, zLeftEnd));

// Arc arrow from zLeftEnd to qExtendDir end (start 0.5 units to the right of zLeftEnd)
const arcArrowStart = zLeftEnd.clone().add(new THREE.Vector3(0.15, 0, 0.01));
const qExtendEnd = q.clone().add(qExtendDir.multiplyScalar(1));
const arcArrowEnd = qExtendEnd.clone().add(new THREE.Vector3(0, 0, 0));
scene.add(flatArcArrow(arcArrowStart, arcArrowEnd));

// γ label (near the arc arrow)
const gammaPos = arcArrowStart.clone().add(arcArrowEnd).multiplyScalar(0.5).add(new THREE.Vector3(-0.2, 0.1, 0));
label("γ", gammaPos);

// Line from ẑ to q̂ (always solid, not occluded)
const zqHatsLine = new THREE.Line(
  new THREE.BufferGeometry().setFromPoints([zHat, qHat]),
  new THREE.LineBasicMaterial({ color: WHITE, depthTest: false })
);
zqHatsLine.renderOrder = 999;
scene.add(zqHatsLine);

// Arrow from z to q (start at edge of z's torus)
const zToQOffset = q.clone().sub(z).normalize().multiplyScalar(0.06);  // torus radius
scene.add(flatArrow(z.clone().add(zToQOffset), q));

// dz label (near the arrow)
const dzPos = z.clone().add(q.clone().sub(z).multiplyScalar(0.5)).add(new THREE.Vector3(0, -0.1, 0));
label("dz", dzPos);

// Dotted line from O to z (not occluded)
scene.add(denseDottedLine(O, z, WHITE, 0.05, 0.05));

// r label (near the O-z line)
const rPos = O.clone().add(z).multiplyScalar(0.5).add(new THREE.Vector3(0.2, 0, 0));
label("r", rPos);

// Dotted line from O going left (not occluded)
const OLeftEnd = new THREE.Vector3(-0.5, 0, 0);
scene.add(denseDottedLine(O, OLeftEnd));

// Dotted arc from left line end to O-z line (angle θ)
scene.add(dottedArc(O, 0.5, Math.PI, Math.atan2(z.z, z.x), 0.01));
scene.add(dottedArc(O, 0.45, Math.PI, Math.atan2(z.z, z.x), 0.01));

// θ label (at midpoint of arc)
label("θ", new THREE.Vector3(-0.3, 0.15, 0.2));

// fork from q to z
const fork1 = fork(q, z, -110);
scene.add(fork1);

// ds label box (left side of plane)
const dsPos = fork1.getHandleEndpoint();
labelBox("ds", dsPos);

const fork2 = fork(qHat, zHat, -60);
scene.add(fork2);

// ds hat label box (left side of plane, above ds)
const dsHatPos = fork2.getHandleEndpoint();
labelBox("d<span style='position:relative'>s<span style='position:absolute;left:-0.1em;right:0;top:-0.2em;text-align:center'>^</span></span>", dsHatPos);



//Helper functions
function fork(p1, p2, rotation = 0, handleLength = 0.7, bufferLength = 0.1, prongLength = 0.1, color = YELLOW) {
  const group = new THREE.Group();
  const up = new THREE.Vector3(0, 1, 0);

  // 1) Baseline from p1 to p2
  const baseline = p2.clone().sub(p1);
  const baselineLen = baseline.length();
  if (baselineLen === 0) return group;
  const baselineDir = baseline.clone().divideScalar(baselineLen);

  // 2) Initial \"direction\" in the base plane, perpendicular to baseline.
  // Start from 'up' projected into the plane perpendicular to baseline.
  let direction = up.clone().sub(
    baselineDir.clone().multiplyScalar(up.dot(baselineDir))
  );

  // Fallback if up is (nearly) parallel to baseline
  if (direction.lengthSq() < 1e-6) {
    const fallback = new THREE.Vector3(0, 0, 1);
    direction = fallback.sub(
      baselineDir.clone().multiplyScalar(fallback.dot(baselineDir))
    );
  }
  direction.normalize();

  // Choose the orientation that makes the dot product with up as small as possible
  // (i.e. direction tilted away from up)
  if (direction.dot(up) > 0) direction.negate();

  // 3) Apply rotation (degrees) within the base plane around the baseline axis
  const rotRad = THREE.MathUtils.degToRad(rotation);
  direction.applyAxisAngle(baselineDir, rotRad);

  // Line 1: from startPoint1 to endPoint1
  const startPoint1 = p1.clone().add(direction.clone().multiplyScalar(bufferLength));
  const endPoint1 = startPoint1.clone().add(direction.clone().multiplyScalar(prongLength));

  const mat = new THREE.LineBasicMaterial({ color, depthTest: false });
  const line1 = new THREE.Line(new THREE.BufferGeometry().setFromPoints([startPoint1, endPoint1]), mat);
  group.add(line1);

  // Line 2: from startPoint2 to endPoint2 (translated copy of line 1)
  const startPoint2 = p2.clone().add(direction.clone().multiplyScalar(bufferLength));
  const endPoint2 = startPoint2.clone().add(direction.clone().multiplyScalar(prongLength));
  const line2 = new THREE.Line(new THREE.BufferGeometry().setFromPoints([startPoint2, endPoint2]), mat);
  group.add(line2);

  const forkBase = new THREE.Line(new THREE.BufferGeometry().setFromPoints([endPoint1, endPoint2]), mat);
  group.add(forkBase);

  // Midpoint of the fork base (between endPoint1 and endPoint2)
  const forkBaseMidpoint = endPoint1.clone().add(endPoint2).multiplyScalar(0.5);
  const handleEndpoint = forkBaseMidpoint.clone().add(direction.clone().multiplyScalar(handleLength));
  const handle = new THREE.Line(new THREE.BufferGeometry().setFromPoints([forkBaseMidpoint, handleEndpoint]), mat);
  group.add(handle);

  // Expose handleEndpoint so callers can query where the handle ends
  group.getHandleEndpoint = function () {
    return handleEndpoint.clone();
  };

  return group;
}

function flatArcArrow(start, end, color = WHITE, shaftWidth = 0.02, headLen = 0.2, headWidth = 0.05, arcHeight = 0.1, bendPlane = null) {
  const group = new THREE.Group();
  const dir = end.clone().sub(start);
  const len = dir.length();
  const dirNorm = dir.clone().normalize();
  const shaftEnd = start.clone().add(dirNorm.clone().multiplyScalar(len - headLen));
  
  // Define up vector for perpendicular calculations (used throughout function)
  const up = new THREE.Vector3(0, 1, 0);
  
  // Calculate perpendicular vector for bending
  let perp;
  if (bendPlane instanceof THREE.Vector3) {
    // Use provided bend plane direction (e.g., for XY bending)
    // Project bendPlane onto plane perpendicular to dirNorm
    const bendPlaneNorm = bendPlane.clone().normalize();
    const proj = bendPlaneNorm.clone().sub(dirNorm.clone().multiplyScalar(bendPlaneNorm.dot(dirNorm)));
    if (proj.length() < 0.001) {
      // If bendPlane is parallel to dir, use default
      perp = dirNorm.clone().cross(up);
      if (perp.length() < 0.001) {
        perp = dirNorm.clone().cross(new THREE.Vector3(1, 0, 0));
      }
    } else {
      perp = proj.normalize();
    }
  } else {
    // Default: calculate perpendicular vector in 3D space
    perp = dirNorm.clone().cross(up);
    if (perp.length() < 0.001) {
      // If dir is parallel to up, use a different reference
      perp = dirNorm.clone().cross(new THREE.Vector3(1, 0, 0));
    }
  }
  perp.normalize();
  
  // Use sign of arcHeight to determine bend direction
  const bendSign = arcHeight >= 0 ? 1 : -1;
  
  // Arc body (curved from start to shaftEnd) - works in 3D
  const midPoint = start.clone().add(dirNorm.clone().multiplyScalar(len / 2 - headLen / 2));
  const arcControl = midPoint.clone().add(perp.clone().multiplyScalar(Math.abs(arcHeight) * bendSign));
  
  // Create arc points using quadratic Bezier curve in 3D
  const arcPts = [];
  for (let i = 0; i <= 32; i++) {
    const t = i / 32;
    const pt = new THREE.Vector3();
    pt.x = (1-t)*(1-t)*start.x + 2*(1-t)*t*arcControl.x + t*t*shaftEnd.x;
    pt.y = (1-t)*(1-t)*start.y + 2*(1-t)*t*arcControl.y + t*t*shaftEnd.y;
    pt.z = (1-t)*(1-t)*start.z + 2*(1-t)*t*arcControl.z + t*t*shaftEnd.z;
    arcPts.push(pt);
  }
  // Add one more point extending past shaftEnd to close gap with head
  const lastSegDir = shaftEnd.clone().sub(arcPts[arcPts.length - 2]).normalize();
  const overlapPt = shaftEnd.clone().add(lastSegDir.clone().multiplyScalar(0.05));
  arcPts.push(overlapPt);
  
  // Create ribbon geometry along the arc - proper 3D perpendiculars
  const shaftVerts = [];
  for (let i = 0; i < arcPts.length - 1; i++) {
    const p1 = arcPts[i];
    const p2 = arcPts[i + 1];
    const segDir = p2.clone().sub(p1).normalize();
    // Calculate perpendicular in 3D using cross product
    let segPerp = segDir.clone().cross(up);
    if (segPerp.length() < 0.001) {
      segPerp = segDir.clone().cross(new THREE.Vector3(1, 0, 0));
    }
    segPerp.normalize();
    const w1 = p1.clone().add(segPerp.clone().multiplyScalar(shaftWidth / 2));
    const w2 = p1.clone().sub(segPerp.clone().multiplyScalar(shaftWidth / 2));
    const w3 = p2.clone().sub(segPerp.clone().multiplyScalar(shaftWidth / 2));
    const w4 = p2.clone().add(segPerp.clone().multiplyScalar(shaftWidth / 2));
    
    shaftVerts.push(w1.x, w1.y, w1.z, w2.x, w2.y, w2.z, w3.x, w3.y, w3.z);
    shaftVerts.push(w1.x, w1.y, w1.z, w3.x, w3.y, w3.z, w4.x, w4.y, w4.z);
  }
  
  const shaftGeo = new THREE.BufferGeometry();
  shaftGeo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(shaftVerts), 3));
  const shaft = new THREE.Mesh(shaftGeo, new THREE.MeshBasicMaterial({ color, side: THREE.DoubleSide, depthTest: false }));
  shaft.renderOrder = 999;
  group.add(shaft);
  
  // Head (flat triangle at end) - align with arc tangent at shaftEnd
  // lastSegDir already calculated above
  const tip = shaftEnd.clone().add(lastSegDir.clone().multiplyScalar(headLen));
  let lastPerp = lastSegDir.clone().cross(up);
  if (lastPerp.length() < 0.001) {
    lastPerp = lastSegDir.clone().cross(new THREE.Vector3(1, 0, 0));
  }
  lastPerp.normalize();
  const base1 = shaftEnd.clone().add(lastPerp.clone().multiplyScalar(headWidth));
  const base2 = shaftEnd.clone().sub(lastPerp.clone().multiplyScalar(headWidth));
  const headGeo = new THREE.BufferGeometry();
  headGeo.setAttribute('position', new THREE.BufferAttribute(new Float32Array([
    tip.x, tip.y, tip.z, base1.x, base1.y, base1.z, base2.x, base2.y, base2.z
  ]), 3));
  const head = new THREE.Mesh(headGeo, new THREE.MeshBasicMaterial({ color, side: THREE.DoubleSide, depthTest: false }));
  head.renderOrder = 999;
  group.add(head);
  
  return group;
}

function flatArrow(start, end, color = WHITE, shaftWidth = 0.03, headLen = 0.15, headWidth = 0.08) {
  const group = new THREE.Group();
  const dir = end.clone().sub(start);
  const len = dir.length();
  const dirNorm = dir.clone().normalize();
  const perp = new THREE.Vector3(-dirNorm.z, 0, dirNorm.x).normalize();
  const shaftEnd = start.clone().add(dirNorm.clone().multiplyScalar(len - headLen));
  
  // Shaft (flat rectangle)
  const s1 = start.clone().add(perp.clone().multiplyScalar(shaftWidth / 2));
  const s2 = start.clone().sub(perp.clone().multiplyScalar(shaftWidth / 2));
  const s3 = shaftEnd.clone().sub(perp.clone().multiplyScalar(shaftWidth / 2));
  const s4 = shaftEnd.clone().add(perp.clone().multiplyScalar(shaftWidth / 2));
  const shaftGeo = new THREE.BufferGeometry();
  shaftGeo.setAttribute('position', new THREE.BufferAttribute(new Float32Array([
    s1.x, s1.y + 0.01, s1.z, s2.x, s2.y + 0.01, s2.z, s3.x, s3.y + 0.01, s3.z,
    s1.x, s1.y + 0.01, s1.z, s3.x, s3.y + 0.01, s3.z, s4.x, s4.y + 0.01, s4.z
  ]), 3));
  const shaft = new THREE.Mesh(shaftGeo, new THREE.MeshBasicMaterial({ color, side: THREE.DoubleSide, depthTest: false }));
  shaft.renderOrder = 999;
  group.add(shaft);
  
  // Head (flat triangle)
  const tip = end.clone();
  const base1 = shaftEnd.clone().add(perp.clone().multiplyScalar(headWidth));
  const base2 = shaftEnd.clone().sub(perp.clone().multiplyScalar(headWidth));
  const headGeo = new THREE.BufferGeometry();
  headGeo.setAttribute('position', new THREE.BufferAttribute(new Float32Array([
    tip.x, tip.y + 0.01, tip.z, base1.x, base1.y + 0.01, base1.z, base2.x, base2.y + 0.01, base2.z
  ]), 3));
  const head = new THREE.Mesh(headGeo, new THREE.MeshBasicMaterial({ color, side: THREE.DoubleSide, depthTest: false }));
  head.renderOrder = 999;
  group.add(head);
  
  return group;
}

function dottedArc(center, radius, startAngle, endAngle, yOffset = 0.01, color = WHITE, dashSize = 0.02, gapSize = 0.02) {
  const arcPts = [];
  for (let i = 0; i <= 32; i++) {
    const a = startAngle + (endAngle - startAngle) * (i / 32);
    arcPts.push(new THREE.Vector3(
      center.x + radius * Math.cos(a),
      center.y + yOffset,
      center.z + radius * Math.sin(a)
    ));
  }
  const arcGeom = new THREE.BufferGeometry().setFromPoints(arcPts);
  const arcMat = new THREE.LineDashedMaterial({ color, dashSize, gapSize, depthTest: false });
  const arc = new THREE.Line(arcGeom, arcMat);
  arc.computeLineDistances();
  arc.renderOrder = 999;
  return arc;
}

function denseDottedLine(start, end, color = WHITE, dashSize = 0.02, gapSize = 0.02) {
  const geom = new THREE.BufferGeometry().setFromPoints([start, end]);
  const mat = new THREE.LineDashedMaterial({ color, dashSize, gapSize, depthTest: false });
  const ln = new THREE.Line(geom, mat);
  ln.computeLineDistances();
  ln.renderOrder = 999;
  return ln;
}

function dot(pos, color = WHITE, size = 0.05) {
  const mesh = new THREE.Mesh(
    new THREE.SphereGeometry(size, 16, 16),
    new THREE.MeshBasicMaterial({ color, depthTest: false })
  );
  mesh.renderOrder = 999;
  mesh.position.copy(pos);
  return mesh;
}

function circle(pos, normal, color = WHITE, radius = 0.06, tubeRadius = 0.012) {
  // Create a torus (3D ring) oriented perpendicular to the normal
  const geom = new THREE.TorusGeometry(radius, tubeRadius, 8, 32);
  const mat = new THREE.MeshBasicMaterial({ color, depthTest: false });
  const torus = new THREE.Mesh(geom, mat);
  torus.position.copy(pos);
  torus.renderOrder = 999;
  
  // Orient the torus to be perpendicular to the normal
  const up = new THREE.Vector3(0, 0, 1);
  const quat = new THREE.Quaternion().setFromUnitVectors(up, normal.clone().normalize());
  torus.quaternion.copy(quat);
  
  return torus;
}

function line(a, b, color = WHITE) {
  const group = new THREE.Group();
  const points = [a, b];
  
  // Solid line for visible parts (normal depth test)
  const solidMat = new THREE.LineBasicMaterial({ color, depthTest: true });
  const solid = new THREE.Line(new THREE.BufferGeometry().setFromPoints(points), solidMat);
  solid.renderOrder = 1;  // Render after hemisphere
  group.add(solid);
  
  // Dashed line for occluded parts (render only behind geometry)
  const dashedMat = new THREE.LineDashedMaterial({
    color,
    dashSize: 0.08,
    gapSize: 0.04,
    depthFunc: THREE.GreaterDepth
  });
  const dashed = new THREE.Line(new THREE.BufferGeometry().setFromPoints(points), dashedMat);
  dashed.computeLineDistances();
  dashed.renderOrder = 1;  // Render after hemisphere
  group.add(dashed);
  
  group.renderOrder = 1;
  return group;
}

function label(text, pos) {
  const div = document.createElement("div");
  div.className = "label";
  div.innerHTML = text;
  const lbl = new CSS3DObject(div);
  lbl.position.copy(pos);
  lbl.scale.setScalar(0.01);
  scene.add(lbl);
}

function labelBox(text, pos) {
  const div = document.createElement("div");
  div.className = "label-box";
  div.innerHTML = text;
  const lbl = new CSS3DObject(div);
  lbl.position.copy(pos);
  lbl.scale.setScalar(0.01);
  scene.add(lbl);
}

function labelLarge(text, pos) {
  const div = document.createElement("div");
  div.className = "label";
  div.style.fontSize = "18px";
  div.innerHTML = text;
  const lbl = new CSS3DObject(div);
  lbl.position.copy(pos);
  lbl.scale.setScalar(0.01);
  scene.add(lbl);
}

//Animation loop
function animate() {
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
  labelRenderer.render(scene, camera);
}
animate();

//Event handlers
addEventListener("resize", () => {
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
  labelRenderer.setSize(innerWidth, innerHeight);
});

// Press 'P' to print camera position
addEventListener("keydown", (e) => {
  if (e.key === 'p' || e.key === 'P') {
    const p = camera.position;
    const t = controls.target;
    console.log(`Position: (${p.x.toFixed(2)}, ${p.y.toFixed(2)}, ${p.z.toFixed(2)})\nTarget: (${t.x.toFixed(2)}, ${t.y.toFixed(2)}, ${t.z.toFixed(2)})`);
  }
});

</script>
</body>
</html>
